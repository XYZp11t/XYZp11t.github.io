---
// Componente para visualizar el modelo 3D de capas solares
---

<div class="modelo-container">
  <div id="contenedor-modelo" style="position:relative;">
    <canvas id="modelo-canvas" draggable="false"></canvas>
    <div id="loading" class="loading-overlay">
      <div class="loading-spinner"></div>
      <p>Cargando modelo 3D...</p>
    </div>
    <div id="error" class="error-overlay" style="display: none;">
      <p>Error al cargar el modelo. Verifica la consola para más detalles.</p>
    </div>
    <div class="controles-checkbox floating" id="controles-checkbox">
      <div class="controles-header" id="controles-header">
        <span>Capas solares</span>
        <button id="btn-minimizar" aria-label="Minimizar">_</button>
      </div>
      <div class="controles-opciones" id="controles-opciones">
        <label><input type="checkbox" id="chk-corte" checked> Aplicar corte</label>
        <label><input type="checkbox" id="chk-cromosfera" checked> Ver cromosfera</label>
        <label><input type="checkbox" id="chk-labels" checked> Mostrar etiquetas</label>
        <button id="btn-reset" class="control-btn">Resetear Vista</button>
        <button id="btn-rotar" class="control-btn">Rotar Modelo</button>
        <button id="btn-textura-cromosfera" class="control-btn">Cambiar textura</button>
      </div>
    </div>
    
    <!-- Contenedor de etiquetas -->
    <div id="labels-container" class="labels-container">
      <!-- Etiquetas estáticas -->
      <div id="label-nucleo" class="layer-label" data-layer="nucleo">
        <span class="info-icon" aria-label="info">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2056a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="8"/></svg>
        </span>
        <span class="label-text">Núcleo</span>
      </div>
      
      <div id="label-zonaRadiativa" class="layer-label" data-layer="zonaRadiativa">
        <span class="info-icon" aria-label="info">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2056a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="8"/></svg>
        </span>
        <span class="label-text">Zona Radiativa</span>
      </div>
      
      <div id="label-zonaConvectiva" class="layer-label" data-layer="zonaConvectiva">
        <span class="info-icon" aria-label="info">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2056a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="8"/></svg>
        </span>
        <span class="label-text">Zona Convectiva</span>
      </div>
      
      <div id="label-fotosfera" class="layer-label" data-layer="fotosfera">
        <span class="info-icon" aria-label="info">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2056a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="8"/></svg>
        </span>
        <span class="label-text">Fotosfera</span>
      </div>
      
      <div id="label-cromosfera" class="layer-label" data-layer="cromosfera">
        <span class="info-icon" aria-label="info">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#2056a8" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><line x1="12" y1="16" x2="12" y2="12"/><line x1="12" y1="8" x2="12" y2="8"/></svg>
        </span>
        <span class="label-text">Cromosfera</span>
      </div>
      
      <!-- SVG para las líneas -->
      <svg id="label-lines" width="100%" height="100%" xmlns="http://www.w3.org/2000/svg" class="lines-container">
        <line class="label-line" data-layer="nucleo"></line>
        <line class="label-line" data-layer="zonaRadiativa"></line>
        <line class="label-line" data-layer="zonaConvectiva"></line>
        <line class="label-line" data-layer="fotosfera"></line>
        <line class="label-line" data-layer="cromosfera"></line>
      </svg>
    </div>
    <button id="btn-fullscreen" class="fullscreen-btn" aria-label="Pantalla completa">⛶</button>
  </div>
  <!-- Elimina la sección de controles principal -->
  <!-- <div class="controles"> ... </div> -->
</div>

<script>
  import * as THREE from 'three';
  import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
  import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

  document.addEventListener('DOMContentLoaded', () => {
    const contenedor = document.getElementById('contenedor-modelo');
    const canvas = document.getElementById('modelo-canvas');
    const loadingElement = document.getElementById('loading');
    const errorElement = document.getElementById('error');
    
    if (!contenedor || !canvas) {
      console.error('No se encontraron los elementos del contenedor');
      return;
    }

    const ancho = contenedor.clientWidth;
    const alto = contenedor.clientHeight;

    console.log('Iniciando visualizador 3D...');
    console.log('Dimensiones del canvas:', ancho, 'x', alto);

    // Configuración de la escena
    const escena = new THREE.Scene();
    // escena.background = new THREE.Color(0x1a1a1a); // Quitamos el fondo sólido

    // Fondo equirectangular
    const textureLoader = new THREE.TextureLoader();
    textureLoader.load('/2k_stars_milky_way.jpg', (texture) => {
      texture.mapping = THREE.EquirectangularReflectionMapping;
      escena.background = texture;
    });

    // Configuración de la cámara
    const camara = new THREE.PerspectiveCamera(75, ancho / alto, 0.1, 1000);
    camara.position.set(10, 10, 10);

    // Configuración del renderizador
    const renderizador = new THREE.WebGLRenderer({ 
      canvas, 
      antialias: true
    });
    renderizador.setSize(ancho, alto);
    renderizador.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    // Controles de órbita
    const controles = new OrbitControls(camara, renderizador.domElement);
    controles.enableDamping = true;
    controles.dampingFactor = 0.05;
    controles.enableRotate = true; // Permitir rotación con mouse
    controles.enablePan = false;   // No permitir arrastrar el modelo fuera de su posición
    // controles.minAzimuthAngle = controles.maxAzimuthAngle = undefined; // (Opcional: limitar ángulos)

    // Iluminación
    const luzAmbiente = new THREE.AmbientLight(0xffffff, 1.0);
    escena.add(luzAmbiente);

    const luzDireccional = new THREE.DirectionalLight(0xffffff, 1.0);
    luzDireccional.position.set(10, 10, 5);
    escena.add(luzDireccional);

    // Cargar el modelo GLB
    const loader = new GLTFLoader();
    let modelo: any = null;
    let rotacionAutomatica = false;
    /** @type {Record<string, THREE.Mesh | undefined>} */
    let meshes = {
      fotosferaExterior: undefined,
      cromosferaExterior: undefined,
      nucleo: undefined,
      zonaRadiativaCorte: undefined,
      zonaConvectivaCorte: undefined,
      fotosferaCorteT: undefined,
      fotosferaCorte: undefined,
      cromosferaCorteT: undefined,
      cromosferaCorte: undefined
    };
    let corteActivo = true;
    let cromosferaActiva = true;
    let labelsActivos = true;
    
    // Variables para las etiquetas
    const labelsContainer = document.getElementById('labels-container');
    const labelLines = document.getElementById('label-lines');
    
    // Hotspots 3D para cada capa (posiciones en el modelo 3D)
    const hotspots3D = {
      nucleo: new THREE.Vector3(0, 0, 0),
      zonaRadiativa: new THREE.Vector3(0.15, 0.5, 0),
      zonaConvectiva: new THREE.Vector3(0.35, 0.8, 0),
      fotosfera: new THREE.Vector3(0.905, 0.4, 0),
      cromosfera: new THREE.Vector3(0.988, 0.2, 0)
    };
    
    // Posiciones 2D de las etiquetas (porcentajes del canvas)
    const labelPositions = {
      nucleo: { x: 55, y: 40 },
      zonaRadiativa: { x: 65, y: 45 },
      zonaConvectiva: { x: 70, y: 50 },
      fotosfera: { x: 75, y: 55 },
      cromosfera: { x: 80, y: 60 }
    };
    
    // Referencias a los elementos DOM de las etiquetas
    const labelElements = {
      nucleo: document.getElementById('label-nucleo'),
      zonaRadiativa: document.getElementById('label-zonaRadiativa'),
      zonaConvectiva: document.getElementById('label-zonaConvectiva'),
      fotosfera: document.getElementById('label-fotosfera'),
      cromosfera: document.getElementById('label-cromosfera')
    };
    
    // Referencias a las líneas SVG
    const lineElements = {
      nucleo: labelLines?.querySelector('[data-layer="nucleo"]') as SVGLineElement,
      zonaRadiativa: labelLines?.querySelector('[data-layer="zonaRadiativa"]') as SVGLineElement,
      zonaConvectiva: labelLines?.querySelector('[data-layer="zonaConvectiva"]') as SVGLineElement,
      fotosfera: labelLines?.querySelector('[data-layer="fotosfera"]') as SVGLineElement,
      cromosfera: labelLines?.querySelector('[data-layer="cromosfera"]') as SVGLineElement
    };

    // Función para proyectar coordenadas 3D a 2D
    function proyectar3Da2D(posicion3D: THREE.Vector3): { x: number, y: number } {
      // Crear un vector temporal para la proyección
      const vector = posicion3D.clone();
      
      // Aplicar la transformación del modelo (rotación, posición, etc.)
      if (modelo) {
        vector.applyMatrix4(modelo.matrixWorld);
      }
      
      // Proyectar usando la cámara
      vector.project(camara);
      
      // Convertir a coordenadas de pantalla
      const canvasRect = canvas?.getBoundingClientRect();
      if (!canvasRect) return { x: 0, y: 0 };
      
      const x = (vector.x * 0.5 + 0.5) * canvasRect.width;
      const y = (-vector.y * 0.5 + 0.5) * canvasRect.height;
      
      return { x, y };
    }

    // Función para ajustar posiciones de hotspots 3D (para debugging)
    function ajustarHotspot3D(capa: string, x: number, y: number, z: number) {
      if (hotspots3D[capa as keyof typeof hotspots3D]) {
        hotspots3D[capa as keyof typeof hotspots3D].set(x, y, z);
        console.log(`Hotspot ${capa} ajustado a:`, x, y, z);
      }
    }

    // Función para actualizar posición de las etiquetas
    function actualizarPosicionEtiquetas() {
      if (!modelo || !canvas) return;
      
      // Obtener las dimensiones actuales del canvas
      const canvasRect = canvas.getBoundingClientRect();
      const canvasWidth = canvasRect.width;
      const canvasHeight = canvasRect.height;
      
      Object.keys(labelElements).forEach(key => {
        const labelElement = labelElements[key as keyof typeof labelElements];
        const lineElement = lineElements[key as keyof typeof lineElements];
        const hotspot3D = hotspots3D[key as keyof typeof hotspots3D];
        const labelPos = labelPositions[key as keyof typeof labelPositions];
        
        if (!labelElement || !lineElement) return;
        
        // Determinar si mostrar la etiqueta
        let mostrar = labelsActivos && corteActivo;
        
        // Si las etiquetas están activas y el corte está activo, verificar cromosfera
        if (mostrar && key === 'cromosfera' && !cromosferaActiva) {
          mostrar = false;
        }
        
        if (mostrar) {
          // Calcular posición en píxeles basada en porcentajes
          const x = (labelPos.x / 100) * canvasWidth;
          const y = (labelPos.y / 100) * canvasHeight;
          
          // Proyectar el hotspot 3D a coordenadas 2D
          const hotspot2D = proyectar3Da2D(hotspot3D);
          
          // Mostrar elementos
          labelElement.style.display = 'block';
          lineElement.style.display = 'block';
          
          // Posicionar etiqueta
          labelElement.style.left = x + 'px';
          labelElement.style.top = y + 'px';
          
          // Configurar línea SVG desde la etiqueta hacia el hotspot proyectado
          lineElement.setAttribute('x1', x.toString());
          lineElement.setAttribute('y1', y.toString());
          lineElement.setAttribute('x2', hotspot2D.x.toString());
          lineElement.setAttribute('y2', hotspot2D.y.toString());
        } else {
          labelElement.style.display = 'none';
          lineElement.style.display = 'none';
        }
      });
    }

    // Función para actualizar visibilidad de las capas
    function actualizarVisibilidad() {
      if (!meshes) return;
      if (corteActivo) {
        // Mostrar solo el sol cortado
        if (meshes.nucleo) (meshes.nucleo as any).visible = true;
        if (meshes.zonaRadiativaCorte) (meshes.zonaRadiativaCorte as any).visible = true;
        if (meshes.zonaConvectivaCorte) (meshes.zonaConvectivaCorte as any).visible = true;
        if (meshes.fotosferaCorteT) (meshes.fotosferaCorteT as any).visible = true;
        if (meshes.fotosferaCorte) (meshes.fotosferaCorte as any).visible = true;
        if (meshes.cromosferaCorteT) (meshes.cromosferaCorteT as any).visible = cromosferaActiva;
        if (meshes.cromosferaCorte) (meshes.cromosferaCorte as any).visible = cromosferaActiva;
        // Ocultar sol completo
        if (meshes.fotosferaExterior) (meshes.fotosferaExterior as any).visible = false;
        if (meshes.cromosferaExterior) (meshes.cromosferaExterior as any).visible = false;
        // Si la cromosfera está desactivada, ocultar cromosfera cortada
        if (!cromosferaActiva) {
          if (meshes.cromosferaCorteT) (meshes.cromosferaCorteT as any).visible = false;
          if (meshes.cromosferaCorte) (meshes.cromosferaCorte as any).visible = false;
        }
      } else {
        // Mostrar solo el sol completo
        if (meshes.fotosferaExterior) (meshes.fotosferaExterior as any).visible = true;
        if (meshes.cromosferaExterior) (meshes.cromosferaExterior as any).visible = cromosferaActiva;
        // Ocultar sol cortado
        if (meshes.nucleo) (meshes.nucleo as any).visible = false;
        if (meshes.zonaRadiativaCorte) (meshes.zonaRadiativaCorte as any).visible = false;
        if (meshes.zonaConvectivaCorte) (meshes.zonaConvectivaCorte as any).visible = false;
        if (meshes.fotosferaCorteT) (meshes.fotosferaCorteT as any).visible = false;
        if (meshes.fotosferaCorte) (meshes.fotosferaCorte as any).visible = false;
        if (meshes.cromosferaCorteT) (meshes.cromosferaCorteT as any).visible = false;
        if (meshes.cromosferaCorte) (meshes.cromosferaCorte as any).visible = false;
      }
    }

    console.log('Intentando cargar modelo desde: /models/capas_test8.glb');

    loader.load('/models/capas_test8.glb', 
      (gltf) => {
        console.log('Modelo cargado exitosamente:', gltf);
        modelo = gltf.scene;
        escena.add(modelo);

        // Centrar el modelo
        const box = new THREE.Box3().setFromObject(modelo as any);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());
        
        console.log('Dimensiones del modelo:', size);
        console.log('Centro del modelo:', center);
        
        modelo.position.sub(center);
        
        // Rotar azimutalmente por defecto
        modelo.rotation.set(0, -Math.PI/2, 0);
        
        // Ajustar la cámara
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camara.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.1; // Más cerca para que el modelo se vea grande
        camara.position.set(cameraZ, cameraZ, cameraZ);
        camara.lookAt(0, 0, 0);
        
        controles.target.set(0, 0, 0);
        controles.update();

        // Mapear los meshes relevantes
        (modelo as any).traverse((obj: any) => {
          if (obj.type === 'Mesh') {
            const mesh = obj as any;
            switch (mesh.name) {
              case 'Fotosfera_Exterior':
                meshes.fotosferaExterior = mesh;
                break;
              case 'Cromosfera_Exterior':
                meshes.cromosferaExterior = mesh;
                break;
              case 'Nucleo':
                meshes.nucleo = mesh;
                break;
              case 'Zona_Radiativa_Corte':
                meshes.zonaRadiativaCorte = mesh;
                break;
              case 'Zona_Convectiva_Corte':
                meshes.zonaConvectivaCorte = mesh;
                break;
              case 'Fotosfera_Corte_T':
                meshes.fotosferaCorteT = mesh;
                break;
              case 'Fotosfera_Corte':
                meshes.fotosferaCorte = mesh;
                break;
              case 'Cromosfera_Corte_T':
                meshes.cromosferaCorteT = mesh;
                break;
              case 'Cromosfera_Corte':
                meshes.cromosferaCorte = mesh;
                break;
            }
          }
        });
        // Inicializar visibilidad
        actualizarVisibilidad();

        // Añadir eventos de clic a las etiquetas
        Object.keys(labelElements).forEach(key => {
          const labelElement = labelElements[key as keyof typeof labelElements];
          if (labelElement) {
            labelElement.addEventListener('click', () => {
              console.log('Clic en etiqueta:', key);
              // Aquí se añadirá la funcionalidad de mostrar información
            });
          }
        });

        // Inicializar posición de etiquetas
        actualizarPosicionEtiquetas();

        // Ocultar loading
        if (loadingElement) {
          loadingElement.style.display = 'none';
        }

        console.log('Modelo configurado y listo para renderizar');
      }, 
      (xhr) => {
        const progress = (xhr.loaded / xhr.total * 100);
        console.log('Progreso de carga:', progress + '%');
        if (loadingElement) {
          const pElement = loadingElement.querySelector('p');
          if (pElement) {
            pElement.textContent = `Cargando modelo 3D... ${Math.round(progress)} %`;}
        }
      }, 
      (error) => {
        console.error('Error al cargar el modelo:', error);
        if (loadingElement) {
          loadingElement.style.display = 'none';
        }
        if (errorElement) {
          errorElement.style.display = 'flex';
        }
      }
    );

    // Función de animación
    function animar() {
      requestAnimationFrame(animar);
      
      if (modelo && rotacionAutomatica) {
        modelo.rotation.y += 0.01;
      }
      
      controles.update();
      renderizador.render(escena, camara);
      
      // Actualizar posición de etiquetas en cada frame
      actualizarPosicionEtiquetas();
    }

    // Manejo de redimensionamiento
    function onWindowResize() {
      if (!contenedor || !canvas) return;
      const nuevoAncho = contenedor.clientWidth;
      const nuevoAlto = contenedor.clientHeight;
      camara.aspect = nuevoAncho / nuevoAlto;
      camara.updateProjectionMatrix();
      renderizador.setSize(nuevoAncho, nuevoAlto);
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      
      // Actualizar posición de etiquetas después del resize
      setTimeout(() => {
        actualizarPosicionEtiquetas();
      }, 100);
    }

    // Controles de botones
    const btnReset = document.getElementById('btn-reset');
    const btnRotar = document.getElementById('btn-rotar');

    // Botón Resetear Vista: ahora pone el modelo en Y = -Math.PI/2
    if (btnReset) {
      btnReset.addEventListener('click', () => {
        if (modelo) {
          modelo.rotation.set(0, -Math.PI/2, 0);
        }
        // Ajustar la cámara para que el modelo se vea más grande
        const box = new THREE.Box3().setFromObject(modelo as any);
        const size = box.getSize(new THREE.Vector3());
        const maxDim = Math.max(size.x, size.y, size.z);
        const fov = camara.fov * (Math.PI / 180);
        let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
        cameraZ *= 1.1;
        camara.position.set(cameraZ, cameraZ, cameraZ);
        camara.lookAt(0, 0, 0);
        controles.target.set(0, 0, 0);
        controles.update();
      });
    }

    if (btnRotar) {
      btnRotar.addEventListener('click', () => {
        rotacionAutomatica = !rotacionAutomatica;
        btnRotar.textContent = rotacionAutomatica ? 'Detener Rotación' : 'Rotar Modelo';
      });
    }

    // Listeners para los checkboxes
    const chkCorte = document.getElementById('chk-corte');
    const chkCromosfera = document.getElementById('chk-cromosfera');
    const chkLabels = document.getElementById('chk-labels');
    
    // Forzar estado inicial checked en DOM y variables
    if (chkCorte instanceof HTMLInputElement) {
      chkCorte.checked = true;
      corteActivo = true;
    }
    if (chkCromosfera instanceof HTMLInputElement) {
      chkCromosfera.checked = true;
      cromosferaActiva = true;
    }
    if (chkLabels instanceof HTMLInputElement) {
      chkLabels.checked = true;
      labelsActivos = true;
    }
    
    if (chkCorte instanceof HTMLInputElement) {
      chkCorte.addEventListener('change', (e) => {
        corteActivo = chkCorte.checked;
        actualizarVisibilidad();
        actualizarPosicionEtiquetas();
      });
    }
    if (chkCromosfera instanceof HTMLInputElement) {
      chkCromosfera.addEventListener('change', (e) => {
        cromosferaActiva = chkCromosfera.checked;
        actualizarVisibilidad();
        actualizarPosicionEtiquetas();
      });
    }
    if (chkLabels instanceof HTMLInputElement) {
      chkLabels.addEventListener('change', (e) => {
        labelsActivos = chkLabels.checked;
        actualizarPosicionEtiquetas();
      });
    }
    // Minimizar controles
    const btnMinimizar = document.getElementById('btn-minimizar');
    const controlesOpciones = document.getElementById('controles-opciones');
    let controlesMinimizados = false;
    if (btnMinimizar && controlesOpciones) {
      btnMinimizar.addEventListener('click', () => {
        controlesMinimizados = !controlesMinimizados;
        if (controlesMinimizados) {
          controlesOpciones.classList.add('minimizado');
        } else {
          controlesOpciones.classList.remove('minimizado');
        }
        btnMinimizar.textContent = controlesMinimizados ? '+' : '_';
      });
    }

    // Pantalla completa en móvil mejorada
    const btnFullscreen = document.getElementById('btn-fullscreen');
    let isFullscreen = false;
    let orientationLocked = false;
    // Detectar iOS/Safari
    function isIOS() {
      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !(typeof window === 'undefined') && (window as any).MSStream === undefined;
    }
    function isSafari() {
      return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
    }
    const esIOS = isIOS();
    const esSafari = isSafari();
    // Mensaje para iOS
    function mostrarMensajeIOS() {
      alert('El modo pantalla completa no es soportado en este dispositivo. Usa el dispositivo en horizontal para mejor experiencia.');
    }
    // Detectar si es móvil
    function isMobile() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
    // En móvil, el tamaño del contenedor lo controla el CSS (media queries). No manipular height/width por JS.
    function ajustarContenedorPorOrientacion() {
      // No hacer nada salvo en desktop si se quiere un alto fijo (opcional)
      if (!contenedor) return;
      if (!(isMobile()) && !(esIOS && esSafari)) {
        contenedor.style.height = '600px';
      }
    }
    // Forzar render inmediato tras resize/orientación
    function forceRender() {
      if (modelo) renderizador.render(escena, camara);
    }
    // Escuchar orientationchange y resize
    window.addEventListener('orientationchange', () => {
      ajustarContenedorPorOrientacion();
      setTimeout(() => {
        onWindowResize();
        forceRender();
        actualizarPosicionEtiquetas();
      }, 100);
    });
    window.addEventListener('resize', () => {
      ajustarContenedorPorOrientacion();
      setTimeout(() => {
        onWindowResize();
        forceRender();
        actualizarPosicionEtiquetas();
      }, 100);
    });
    if (btnFullscreen && contenedor) {
      btnFullscreen.addEventListener('click', async () => {
        if (esIOS || esSafari) {
          mostrarMensajeIOS();
          return;
        } else {
          if (!isFullscreen) {
            if (contenedor.requestFullscreen) {
              await contenedor.requestFullscreen();
              isFullscreen = true;
              // Forzar orientación horizontal en móvil
              if (window.screen.orientation && window.innerWidth < 800) {
                try {
                  await (window.screen.orientation as any).lock('landscape');
                  orientationLocked = true;
                } catch (e) {
                  // Puede fallar en algunos navegadores
                  orientationLocked = false;
                }
              }
            }
          } else {
            if (document.exitFullscreen) {
              await document.exitFullscreen();
              isFullscreen = false;
              // Restaurar orientación
              if (window.screen.orientation && orientationLocked) {
                try {
                  await (window.screen.orientation as any).unlock();
                } catch (e) {}
                orientationLocked = false;
              }
            }
          }
        }
      });
      // Detectar salida de fullscreen por otros medios
      document.addEventListener('fullscreenchange', () => {
        ajustarContenedorPorOrientacion();
        isFullscreen = !!document.fullscreenElement;
        if (!isFullscreen && window.screen.orientation && orientationLocked) {
          try { (window.screen.orientation as any).unlock(); } catch (e) {}
          orientationLocked = false;
        }
        // Forzar resize tras salir de fullscreen
        setTimeout(() => {
          onWindowResize();
          forceRender();
          actualizarPosicionEtiquetas();
        }, 100);
      });
    }
    // Ajuste inicial al cargar
    ajustarContenedorPorOrientacion();
    animar();

    // Funciones de debugging para ajustar hotspots y labels
    (window as any).ajustarHotspot3D = ajustarHotspot3D;
    (window as any).hotspots3D = hotspots3D;
    
    // Función para ajustar posiciones de labels 2D (para debugging)
    function ajustarLabel2D(capa: string, x: number, y: number) {
      if (labelPositions[capa as keyof typeof labelPositions]) {
        // Convertir coordenadas de píxeles a porcentajes
        if (!canvas) return;
        const canvasRect = canvas.getBoundingClientRect();
        const porcentajeX = (x / canvasRect.width) * 100;
        const porcentajeY = (y / canvasRect.height) * 100;
        
        labelPositions[capa as keyof typeof labelPositions].x = porcentajeX;
        labelPositions[capa as keyof typeof labelPositions].y = porcentajeY;
        
        console.log(`Label ${capa} ajustado a:`, x, y, `(${porcentajeX.toFixed(1)}%, ${porcentajeY.toFixed(1)}%)`);
        actualizarPosicionEtiquetas();
      }
    }
    
    // Función para obtener las posiciones actuales de las etiquetas
    function obtenerPosicionesLabels() {
      console.log('Posiciones actuales de las etiquetas (porcentajes):');
      Object.keys(labelPositions).forEach(capa => {
        const pos = labelPositions[capa as keyof typeof labelPositions];
        console.log(`${capa}: x=${pos.x.toFixed(1)}%, y=${pos.y.toFixed(1)}%`);
      });
    }
    
    // Función para posicionar etiquetas usando porcentajes del canvas
    function posicionarEtiquetaPorcentaje(capa: string, porcentajeX: number, porcentajeY: number) {
      if (labelPositions[capa as keyof typeof labelPositions]) {
        labelPositions[capa as keyof typeof labelPositions].x = porcentajeX;
        labelPositions[capa as keyof typeof labelPositions].y = porcentajeY;
        console.log(`Label ${capa} posicionado en: ${porcentajeX}%, ${porcentajeY}%`);
        actualizarPosicionEtiquetas();
      }
    }
    
    // Función para posicionar todas las etiquetas usando porcentajes
    function posicionarTodasEtiquetasPorcentaje() {
      const posiciones = {
        nucleo: { x: 55, y: 40 },
        zonaRadiativa: { x: 65, y: 45 },
        zonaConvectiva: { x: 70, y: 50 },
        fotosfera: { x: 75, y: 55 },
        cromosfera: { x: 80, y: 60 }
      };
      
      Object.keys(posiciones).forEach(capa => {
        const pos = posiciones[capa as keyof typeof posiciones];
        posicionarEtiquetaPorcentaje(capa, pos.x, pos.y);
      });
    }
    
    (window as any).ajustarLabel2D = ajustarLabel2D;
    (window as any).obtenerPosicionesLabels = obtenerPosicionesLabels;
    (window as any).posicionarEtiquetaPorcentaje = posicionarEtiquetaPorcentaje;
    (window as any).posicionarTodasEtiquetasPorcentaje = posicionarTodasEtiquetasPorcentaje;
    (window as any).labelPositions = labelPositions;
    
    console.log('Funciones de debugging disponibles:');
    console.log('- ajustarHotspot3D(capa, x, y, z)');
    console.log('- hotspots3D (objeto con todas las posiciones)');
    console.log('- ajustarLabel2D(capa, x, y)');
    console.log('- obtenerPosicionesLabels()');
    console.log('- posicionarEtiquetaPorcentaje(capa, porcentajeX, porcentajeY)');
    console.log('- posicionarTodasEtiquetasPorcentaje()');
    console.log('- labelPositions (objeto con todas las posiciones en porcentajes)');
 
    // --- Cambiar textura de la cromosfera ---
    const btnTexturaCromosfera = document.getElementById('btn-textura-cromosfera');
    let texturaAlternativaCargada = false;
    let texturaOriginalCromosfera: THREE.Texture | null = null;
    let texturaOriginalCromosferaCorte: THREE.Texture | null = null;
    let texturaOriginalCromosferaCorteT: THREE.Texture | null = null;
    let texturaAlternativa: THREE.Texture | null = null;
    if (btnTexturaCromosfera) {
      btnTexturaCromosfera.addEventListener('click', () => {
        if (!meshes.cromosferaExterior && !meshes.cromosferaCorte && !meshes.cromosferaCorteT) return;
        // Cargar textura alternativa si no está cargada
        if (!texturaAlternativa) {
          const loader = new THREE.TextureLoader();
          loader.load('/2k_sun.jpg', (tex) => {
            texturaAlternativa = tex;
            aplicarTexturaCromosfera();
          });
        } else {
          aplicarTexturaCromosfera();
        }
      });
    }
    function aplicarTexturaCromosfera() {
      // Guardar texturas originales la primera vez
      if (!texturaOriginalCromosfera && meshes.cromosferaExterior) {
        texturaOriginalCromosfera = ((meshes.cromosferaExterior as THREE.Mesh).material as THREE.MeshStandardMaterial).map;
      }
      if (!texturaOriginalCromosferaCorte && meshes.cromosferaCorte) {
        texturaOriginalCromosferaCorte = ((meshes.cromosferaCorte as THREE.Mesh).material as THREE.MeshStandardMaterial).map;
      }
      if (!texturaOriginalCromosferaCorteT && meshes.cromosferaCorteT) {
        texturaOriginalCromosferaCorteT = ((meshes.cromosferaCorteT as THREE.Mesh).material as THREE.MeshStandardMaterial).map;
      }
      // Alternar textura
      texturaAlternativaCargada = !texturaAlternativaCargada;
      if (meshes.cromosferaExterior) {
        ((meshes.cromosferaExterior as THREE.Mesh).material as THREE.MeshStandardMaterial).map = texturaAlternativaCargada ? texturaAlternativa : texturaOriginalCromosfera;
        ((meshes.cromosferaExterior as THREE.Mesh).material as THREE.MeshStandardMaterial).needsUpdate = true;
      }
      if (meshes.cromosferaCorte) {
        ((meshes.cromosferaCorte as THREE.Mesh).material as THREE.MeshStandardMaterial).map = texturaAlternativaCargada ? texturaAlternativa : texturaOriginalCromosferaCorte;
        ((meshes.cromosferaCorte as THREE.Mesh).material as THREE.MeshStandardMaterial).needsUpdate = true;
      }
      if (meshes.cromosferaCorteT) {
        ((meshes.cromosferaCorteT as THREE.Mesh).material as THREE.MeshStandardMaterial).map = texturaAlternativaCargada ? texturaAlternativa : texturaOriginalCromosferaCorteT;
        ((meshes.cromosferaCorteT as THREE.Mesh).material as THREE.MeshStandardMaterial).needsUpdate = true;
      }
      if (btnTexturaCromosfera) {
        btnTexturaCromosfera.textContent = texturaAlternativaCargada ? 'Restaurar textura' : 'Cambiar textura';
      }
    }
  });
</script>

<style>
  .modelo-container {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    max-width: 1200px;
    margin: 0 auto;
    /* Safe area para iPhone notch (solo top/bottom) */
    padding-top: env(safe-area-inset-top, 0px);
    padding-bottom: env(safe-area-inset-bottom, 0px);
    box-sizing: border-box;
  }

  .floating {
    position: absolute;
    top: 1rem;
    left: 1rem;
    z-index: 20;
    min-width: 220px;
    max-width: 90vw;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
  }

  .fullscreen-btn {
    position: absolute;
    top: 1rem;
    right: 1rem;
    z-index: 21;
    background: #fff;
    border: none;
    border-radius: 50%;
    width: 2.5rem;
    height: 2.5rem;
    font-size: 1.5rem;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.2s;
  }
  .fullscreen-btn:active, .fullscreen-btn:focus {
    background: #e0e0e0;
  }

  #contenedor-modelo {
    width: 90vw;
    max-width: 90vw;
    min-width: 90vw;
    height: auto;
    position: relative;
    left: 50%;
    transform: translateX(-50%);
    /* Safe area para iPhone notch (solo top/bottom) */
    padding-top: env(safe-area-inset-top, 0px);
    padding-bottom: env(safe-area-inset-bottom, 0px);
    box-sizing: border-box;
    border-radius: 8px;
    overflow: hidden;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
  }

  /* Media queries para móvil vertical y horizontal */
  @media (max-width: 900px) and (orientation: portrait) {
    #contenedor-modelo {
      height: 300px;
    }
  }
  @media (max-width: 900px) and (orientation: landscape) {
    #contenedor-modelo {
      height: 400px;
    }
  }

  #modelo-canvas {
    width: 100%;
    height: 100%;
    display: block;
    box-sizing: border-box;
    user-select: none;
    -webkit-user-drag: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
  }

  .loading-overlay, .error-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    color: white;
    z-index: 10;
  }

  .loading-spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid white;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin-bottom: 1rem;
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  .controles {
    display: flex;
    flex-direction: column;
    gap: 1rem;
    align-items: center;
  }

  .controles button {
    padding: 0.75rem 1.5rem;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 500;
    transition: all 0.3s ease;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }

  .controles button:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  .controles button:active {
    transform: translateY(0);
  }

  .info {
    text-align: center;
    color: #8f8f8f;
    font-size: 0.9rem;
  }

  .info p {
    margin: 0;
  }

  .controles-checkbox {
    background: rgba(48, 120, 255, 0.92); 
    border-radius: 8px;
    box-shadow: 0 2px 6px rgba(0,0,0,0.07);
    padding: 0.5rem 0.5rem 0.5rem 0.5rem;
    min-width: 0;
    max-width: none;
    width: fit-content;
    margin-bottom: 1rem;
    display: flex;
    flex-direction: column;
    gap: 0.7rem;
  }
  .controles-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    margin-bottom: 0.1rem;
    background: #2056a8;
    color: #fff;
    border-radius: 6px 6px 0 0;
    padding: 0.3rem 0.3rem;
    white-space: nowrap;
  }
  .controles-header button {
    background: #2056a8;
    border: none;
    font-size: 1.2rem;
    cursor: pointer;
    color: #fff;
    padding: 0 0.5rem;
    border-radius: 4px;
    transition: background 0.2s, color 0.2s;
    white-space: nowrap;
  }
  .controles-header button:hover {
    background: #133a6b;
    color: #e3f0ff;
  }
  .controles-opciones {
    display: flex;
    flex-direction: column;
    margin-top: -0.4rem;
    margin-bottom: 0.2rem;
    margin-left: 0.2rem;
    margin-right: 0.2rem;
    gap: 0.1rem;
    padding: 0;
    transition: none;
  }
  .controles-opciones.minimizado {
    display: none;
    gap: 0;
    padding: 0;
  }
  .controles-opciones label {
    display: flex;
    align-items: center;
    gap: 0.4rem;
    font-size: 1rem;
    margin-bottom: 0.1rem;
    cursor: pointer;
    color: #fff;
    text-shadow: 0 1px 2px #133a6b44;
    white-space: nowrap;
  }
  .controles-opciones button {
    display: block;
    width: 100%;
    margin: 0;
    background: linear-gradient(135deg, #6bb6ff 0%, #3a7bd5 100%);
    color: #fff;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 1rem;
    font-weight: 500;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
    transition: all 0.3s ease;
    padding: 0.6rem 0.5rem;
    white-space: nowrap;
  }
  /* Espaciado extra entre los botones de acción */
  #btn-reset { margin-bottom: 0.3rem; }
  #btn-rotar { margin-bottom: 0.3rem; }
  .controles-opciones button:hover {
    background: linear-gradient(135deg, #3a7bd5 0%, #6bb6ff 100%);
    color: #e3f0ff;
  }
  .controles-opciones button {
    display: block;
    width: 100%;
    margin: 0;
  }

  @media (max-width: 768px) {
    #contenedor-modelo {
      height: 400px;
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
    }
    
    .controles {
      flex-direction: row;
      justify-content: center;
      flex-wrap: wrap;
    }
    .floating {
      top: 0.5rem;
      left: 0.5rem;
      min-width: 0;
      max-width: none;
      width: fit-content;
      font-size: 0.92rem;
      padding: 0.2rem;
    }
    /* .fullscreen-btn { display: flex; }  Ya está visible en todos los dispositivos */
    #contenedor-modelo.fullscreen {
      height: 100vh !important;
      width: 100vw !important;
      border-radius: 0;
    }
  }
  @media (max-width: 480px) {
    #contenedor-modelo {
      height: 250px;
      padding-top: env(safe-area-inset-top, 0px);
      padding-bottom: env(safe-area-inset-bottom, 0px);
      padding-left: env(safe-area-inset-left, 0px);
      padding-right: env(safe-area-inset-right, 0px);
    }
    .floating {
      min-width: 0;
      max-width: none;
      width: fit-content;
      font-size: 0.88rem;
      padding: 0.1rem;
    }
  }

  /* Estilos para las etiquetas */
  .labels-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 15;
    overflow: visible;
    font-family: Arial, sans-serif;
  }

  .lines-container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 14;
    overflow: visible;
  }

  .label-line {
    stroke: #00eaff;
    stroke-width: 3;
    stroke-dasharray: none;
    opacity: 1;
  }

  /* Estilos para las etiquetas mejorados */
  .layer-label {
    position: absolute !important;
    background: rgba(20, 40, 80, 0.98) !important;
    border: 2px solid #00eaff !important;
    border-radius: 10px !important;
    padding: 8px 16px 8px 10px !important;
    font-size: 15px !important;
    font-weight: 600 !important;
    color: #fff !important;
    cursor: pointer !important;
    pointer-events: auto !important;
    box-shadow: 0 2px 12px rgba(0, 0, 0, 0.25) !important;
    transition: all 0.3s ease !important;
    white-space: nowrap !important;
    z-index: 1000 !important;
    display: flex !important;
    align-items: center !important;
    gap: 0.5em !important;
    user-select: none !important;
    transform: translateZ(0) !important;
    font-family: Arial, sans-serif !important;
    line-height: 1.2 !important;
  }
  .layer-label:hover {
    background: #001b63 !important;
    color: #ff00b3 !important;
    border-color: #cf68e9;
    box-shadow: 0 4px 16px rgba(91, 158, 37, 0.822);
    scale: 1.05;
  }
  .layer-label .info-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-right: 2px;
  }
  .layer-label .info-icon svg {
    display: block;
    stroke: #00fcef;
    background: #2a003d;
    border-radius: 50%;
    padding: 1px;
  }
  .layer-label:hover .info-icon svg {
    stroke: #ff00b3;
    background: #000f3f;
  }
  .layer-label .label-text {
    display: inline-block;
    vertical-align: middle;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }
  
  /* Cambiar la línea SVG a continua y color cyan brillante */
  .label-line {
    stroke: #00eaff;
    stroke-width: 3;
    stroke-dasharray: none;
    opacity: 1;
    filter: drop-shadow(0 1px 2px rgba(0, 234, 255, 0.3));
  }
  
  /* Asegurar que las etiquetas sean visibles en todos los navegadores */
  .layer-label {
    -webkit-font-smoothing: antialiased !important;
    -moz-osx-font-smoothing: grayscale !important;
    backface-visibility: hidden !important;
  }
  
  /* Estilo específico para etiquetas cuando están activas */
  .layer-label[style*="display: block"] {
    opacity: 1 !important;
    visibility: visible !important;
  }
  
  /* Estilo específico para etiquetas cuando están ocultas */
  .layer-label[style*="display: none"] {
    opacity: 0 !important;
    visibility: hidden !important;
  }
</style>